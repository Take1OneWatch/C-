#include "stdio.h"
#include "iostream"
#include "malloc.h"
#include "queue"
#include "stack"
using namespace std;
typedef  char TelernType; 

typedef struct BTreeNode 
{
	TelernType data ;      //树的数据域为字符型
	struct BTreeNode *LChild ;         //*左孩子指针
	struct BTreeNode *RChild ;         //*右孩子指针
}BTree; 

BTree *CreatBTree()
{
	BTree *T;
	char x;
	scanf("%c",&x);getchar();
	if (x=='0') T=NULL;
	else 
	{	T=new BTree;
		T->data=x;
		printf(" 请输入 %c 结点的左孩子：",T->data);
		T->LChild=CreatBTree();
		printf(" 请输入 %c 结点的右孩子：",T->data);
		T->RChild=CreatBTree();
	}
	return T;
}

//前序递归遍历二叉树
void PreOrder(BTree *T)
{  
	if(T!=NULL)
	{ 
       printf("%c",T->data);
       PreOrder(T->LChild);
       PreOrder(T->RChild);
	}
}


//中序递归遍历二叉树
void InOrder(BTree *T)
{  
	if(T!=NULL)
	{
        InOrder(T->LChild);
        printf("%c",T->data);
        InOrder(T->RChild);
	}
}

//后序递归遍历二叉树
void postOrder(BTree *T)
{  
	if(T!=NULL)
	{
        postOrder(T->LChild);
        postOrder(T->RChild);
        printf("%c",T->data);
	}
}

//层次遍历
void LevelOrder(BTree *T)
{
	BTreeNode *queue[50];//定义队列有50个空间
	if(T==NULL)
		return;
	int front,rear;
	front=rear=0;
	queue[rear++]=T;//跟节点存入队列
	while(front!=rear)//如果队尾指针不等于队头指针时
	{
		printf("%c",queue[front]->data);//依次从队列中输出节点数
		if(queue[front]->LChild!=NULL)//结点左孩子指针入队列
		{
			queue[rear]=queue[front]->LChild;
			rear++;//队尾指针后移
		}
        if(queue[front]->RChild!=NULL)
		{
			queue[rear]=queue[front]->RChild;//结点右孩子指针入队列
			rear++;
		}
		front++;//头指针后移
	}
}
//树的高度
int TreeHeight(BTree *T)
{
	int lh,rh;
	if (T==NULL) return 0;
	else
	{
		lh=TreeHeight(T->LChild );
		rh=TreeHeight(T->RChild );
		if (lh>rh) return lh+1;
		else return rh+1;
	}
}
//叶子节点数
int coun=0;
void leafnum(BTree *T)
{
	if(T)        //树不空
	{	if (T->LChild==NULL && T->RChild ==NULL)
		coun++;
		leafnum(T->LChild );
		leafnum(T->RChild ) ;
	}
}

void main()
{
	BTree *T;
	int k;	
	do
    {  
	printf("\n\n\n\n");
    printf("\t\t\t  树 子系统\n");
	printf("\t\t******************************\n");
	printf("\t\t*        1----建二叉树　 　　*\n");
	printf("\t\t*        2----前序遍历 　　　*\n");
	printf("\t\t*        3----中序遍历　 　　*\n");
	printf("\t\t*        4----后序遍历　 　　*\n");
    printf("\t\t*        5----层次遍历　 　　*\n");
	printf("\t\t*        6----求树高度     　*\n");
	printf("\t\t*        7----叶子个数 　   *\n");
	printf("\t\t*        0----返　　回　 　　*\n");
	printf("\t\t******************************\n");
	printf("\t\t 请选择菜单项(0－7)：");
	scanf("%d",&k);getchar();
	if (k==1)
	{	printf("\n 请输入此树的根结点:");
		T=CreatBTree();                 //建立二叉树
	}
	else if (k==2)          
	{
		printf("\n   此树前序遍历的顺序:");
		PreOrder(T);                    
	}
	else if (k==3)
	{	printf("\n   此树中序遍历的顺序:");
		InOrder(T);                    	
	}
	else if (k==4)      
	{	
		printf("\n   此树后序遍历的顺序:");
		postOrder(T);                    
	}
	else if(k==5)
	{
        	printf("\n   此树层次遍历的顺序:");
			LevelOrder(T);
	}
	else if (k==6)        
	 {	
                           
		printf("\n此树的高度是：%d", TreeHeight(T)   ); 
	}
	 else if (k==7)       
	 {coun=0;	
      leafnum(T);                    
		printf("\n此树叶子结点个数是：%d",coun      ); 
	}
	}while(k!=0);
}
